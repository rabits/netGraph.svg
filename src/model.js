/*!
 * netGraph model
 * Classes for the data
 * @version 0.0.1
 * @copyright Rabit <home@rabits.org>
 * @license MIT
 */
'use strict'

// Engine base class
class EngineBase {
  constructor(cfg) {
    this._ = {}
    this._v = {}

    if( typeof cfg === 'string' )
      cfg = this.unpackCfgString(cfg)

    this._.id = cfg.id || Math.floor(Math.random() * 8999999999) + 100000000
    this._.name = cfg.name
    this._.description = cfg.description
  }

  get id() { return this._.id }
  get type() { return this.constructor.name }
  get name() { return this._.name || this.id }
  get description() { return this._.description }

  fromString(str) {
    const cls_name = str.substring(0, str.indexOf(':'))
    const data = str.substring(str.indexOf(':')+1)
    var cls = Node.NAMESPACE ? Node.NAMESPACE[cls_name] : window[cls_name]
    return new cls(data)
  }

  // Simple deserializer like "<value>" or by rules in the specific class
  unpackCfgString(str) {
    return {
      name: str,
      description: 'Autogenerated',
    }
  }

  toString() { this.type + ':' + this.id }

  toJSON() { JSON.stringify({data: this._, view: this._v}) }
}

// Basic class for nodes
class Node extends EngineBase {
  constructor(cfg) {
    super(cfg)
    this._.owner = cfg.owner
    this._.parent = cfg.parent

    this._.childrens = []
    this.addChildrens(cfg.childrens)

    this._.showChildrens = cfg.showChildrens || false
    this.setShowChildrens(this._.showChildrens)
  }

  get owner() { return this._.owner }
  setOwner(val) { this._.owner = val }
  get parent() { return this._.parent || this.owner }
  get childrens() { return this._.childrens }
  get showChildrens() { return this._.showChildrens }

  addChildrens(childs, type = null) {
    if( ! childs ) return
    if( ! (childs instanceof Array) )
      childs = [childs]
    if( type )
      childs = childs.map(s => 'Tag:'+s)
    for( let c of childs ) {
      if( typeof c === 'string' )
        c = this.fromString(c)
      if( ! (c instanceof Node) )
        throw new Error('Unable to add non-Node child ' + c)
      this._.childrens.push(c)
      c.setOwner(this)
    }
    return this
  }

  setShowChildrens(show = !this._.showChildrens) {
    if( show === this._.showChildrens ) return

    this._.showChildrens = show
    if( show ) {
      DATA.nodes = DATA.nodes.concat(this._.childrens.filter( n => !DATA.nodes.includes(n) ))
      this._.childrens.forEach( c => createLink(RelationLink, this, c) )
    } else {
      this._.childrens.forEach( c => { c.setShowChildrens(false)} )
      DATA.links = DATA.links.filter( l => ! (l instanceof RelationLink && l.source === this) )
      DATA.nodes = DATA.nodes.filter( n => !this._.childrens.includes(n) )
    }
  }
}

class Group extends Node {
  constructor(cfg) {
    super(cfg)
  }
}

// Rules for links
class Connector extends EngineBase {
  constructor(cfg) {
    super(cfg)
    this._.sourceSelector = cfg.sourceSelector
    this._.targetSelector = cfg.targetSelector
    this._.targetResource = cfg.targetResource
    this._.owner = cfg.owner
    this._.approved = cfg.approved
    this._.active = cfg.active
  }

  get sourceSelector() { return this._.sourceSelector }
  get targetSelector() { return this._.targetSelector }
  get targetResource() { return this._.targetResource }
  get owner() { return this._.owner }
  get approved() { return this._.approved }
  get active() { return this._.active }
}

// Basic class for links
class Link extends EngineBase {
  constructor(cfg) {
    super(cfg)
    this._.connector = cfg.connector
    this._.source = cfg.source
    this._.target = cfg.target
    this.right = true // TODO
  }

  get connector() { return this._.owner }
  get source() { return this._.source }
  get target() { return this._.target }
}

class RelationLink extends Link {
  constructor(cfg) {
    super(cfg)
  }
}

// Network namespace for netGraph classes
let Network = {}
Node.NAMESPACE = Network

Network.Owner = class Owner extends Node {
  constructor(cfg) {
    super(cfg)
  }
}

Network.Project = class Project extends Node {
  constructor(cfg) {
    super(cfg)
  }
}

Network.Net = class Net extends Node {
  constructor(cfg) {
    super(cfg)
  }
}

Network.Subnet = class Subnet extends Node {
  constructor(cfg) {
    super(cfg)
    this._.cidrRange = cfg.cidrRange || '0.0.0.0/0'
  }

  get cidrRange() { return this._.cidrRange }

  unpackCfgString(str) {
    return {
      name: str,
      cidrRange: str,
      description: 'Autogenerated',
    }
  }
}

Network.Address = class Address extends Node {
  constructor(cfg) {
    super(cfg)
    this._.address = cfg.address || '0.0.0.0'
  }

  get address() { return this._.address }

  unpackCfgString(str) {
    return {
      name: str,
      address: str,
      description: 'Autogenerated',
    }
  }
}

Network.Environment = class Environment extends Node {
  constructor(cfg) {
    super(cfg)
  }
}

Network.Service = class Service extends Node {
  constructor(cfg) {
    super(cfg)
    this._.url = cfg.url
    if( cfg.tags )
      this.addChildrens(cfg.tags, 'Tag')
  }

  get url() { return this._.url }
}

Network.Tag = class Tag extends Node {
  constructor(cfg) {
    super(cfg)
  }
}
